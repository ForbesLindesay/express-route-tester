{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index.js","node_modules/debounce/index.js","node_modules/path-to-regexp/index.js","node_modules/debounce/node_modules/date-now/index.js","node_modules/path-to-regexp/node_modules/isarray/index.js"],"names":["escape","str","replace","hide","selector","elements","document","querySelectorAll","i","length","style","display","show","update","keys","regexp","pathRegexp","_","value","textContent","toString","innerHTML","map","key","name","optional","join","updatePath","path","test","result","exec","require","debounce","querySelector","bind","addEventListener","now","module","exports","func","wait","immediate","later","last","timestamp","timeout","setTimeout","apply","context","args","this","arguments","callNow","escapeGroup","group","attachKeys","re","flags","options","sensitive","regexpToRegexp","groups","source","match","push","delimiter","repeat","arrayToRegexp","parts","pathToRegexp","RegExp","replacePath","escaped","prefix","capture","suffix","index","PATH_REGEXP","isArray","strict","end","route","endsWithSlash","charAt","slice","Date","getTime","Array","arr","Object","prototype","call"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar pathRegexp = require('path-to-regexp');\nvar debounce = require('debounce');\n\nvar _ = document.querySelector.bind(document);\n\nfunction escape(str) {\n  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\\"/g, '&quot;');\n}\nfunction hide(selector) {\n  var elements = document.querySelectorAll(selector);\n  for (var i = 0; i < elements.length; i++) {\n    elements[i].style.display = 'none';\n  }\n}\nfunction show(selector) {\n  var elements = document.querySelectorAll(selector);\n  for (var i = 0; i < elements.length; i++) {\n    elements[i].style.display = null;\n  }\n}\n\n_('#inputRoute').addEventListener('input', debounce(update, 100), false);\n_('#inputPath').addEventListener('input', debounce(updatePath, 100), false);\n\nvar keys, regexp;\nfunction update() {\n  keys = [];\n  regexp = pathRegexp(_('#inputRoute').value, keys);\n  _('#regexp-display').textContent = regexp.toString();\n  if (keys.length) {\n    _('#keys-display').innerHTML = '<ol>' + keys.map(function wrap(key) {\n      return '<li>' + escape(key.name) + (key.optional ? ' (optional)' : '') + '</li>';\n    }).join('') + '</ol>';\n  } else {\n    _('#keys-display').innerHTML = 'There are no keys captured by this route';\n  }\n  updatePath();\n}\nfunction updatePath() {\n  var path = _('#inputPath').value;\n  if (regexp.test(path)) {\n    hide('.is-not-match');\n    show('.is-match');\n    var result = regexp.exec(path);\n    _('#keys-results-display').innerHTML = '<dl class=\"dl-horizontal\">' + keys.map(function (key, i) {\n      return '<dt>' + escape(key.name) + '</dt><dd>' +\n      (result[i + 1] ? escape(result[i + 1]) : '&nbsp;') + '</dd>';\n    }).join('') + '</dl>';\n  } else {\n    show('.is-not-match');\n    hide('.is-match');\n  }\n}\nupdate();\n","\n/**\n * Module dependencies.\n */\n\nvar now = require('date-now');\n\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing.\n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nmodule.exports = function debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = now() - timestamp;\n\n    if (last < wait && last > 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function debounced() {\n    context = this;\n    args = arguments;\n    timestamp = now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n};\n","var isArray = require('isarray');\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\n  // \"/route(\\\\d+)\" => [undefined, undefined, undefined, \"\\d+\", undefined]\n  '([\\\\/.])?(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^)])*)\\\\))?|\\\\(((?:\\\\\\\\.|[^)])*)\\\\))([+*?])?',\n  // Match regexp special characters that are always escaped.\n  '([.+*?=^!:${}()[\\\\]|\\\\/])'\n].join('|'), 'g');\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re;\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i';\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name:      i,\n        delimiter: null,\n        optional:  false,\n        repeat:    false\n      });\n    }\n  }\n\n  return attachKeys(path, keys);\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n  return attachKeys(regexp, keys);\n}\n\n/**\n * Replace the specific tags with regexp strings.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @return {String}\n */\nfunction replacePath (path, keys) {\n  var index = 0;\n\n  function replace (_, escaped, prefix, key, capture, group, suffix, escape) {\n    if (escaped) {\n      return escaped;\n    }\n\n    if (escape) {\n      return '\\\\' + escape;\n    }\n\n    var repeat   = suffix === '+' || suffix === '*';\n    var optional = suffix === '?' || suffix === '*';\n\n    keys.push({\n      name:      key || index++,\n      delimiter: prefix || '/',\n      optional:  optional,\n      repeat:    repeat\n    });\n\n    prefix = prefix ? ('\\\\' + prefix) : '';\n    capture = escapeGroup(capture || group || '[^' + (prefix || '\\\\/') + ']+?');\n\n    if (repeat) {\n      capture = capture + '(?:' + prefix + capture + ')*';\n    }\n\n    if (optional) {\n      return '(?:' + prefix + '(' + capture + '))?';\n    }\n\n    // Basic parameter support.\n    return prefix + '(' + capture + ')';\n  }\n\n  return path.replace(PATH_REGEXP, replace);\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || [];\n\n  if (!isArray(keys)) {\n    options = keys;\n    keys = [];\n  } else if (!options) {\n    options = {};\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options);\n  }\n\n  if (isArray(path)) {\n    return arrayToRegexp(path, keys, options);\n  }\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = replacePath(path, keys);\n  var endsWithSlash = path.charAt(path.length - 1) === '/';\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys);\n}\n","module.exports = Date.now || now\n\nfunction now() {\n    return new Date().getTime()\n}\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n"]}